from dataclasses import replace
from datetime import datetime, timezone
from uuid import uuid4

from src.core.domain.execution_intent import ExecutionIntent
from src.core.domain.execution_result import ExecutionFailureType
from src.core.domain.resource import ResourceCost
from src.execution.domain.execution_job import ExecutionJob, ExecutionJobState
from src.execution.limits.adaptive_rate_controller import AdaptiveRateController
from src.execution.queue.execution_queue import InMemoryExecutionQueue
from src.execution.results.execution_result_inbox import InMemoryExecutionResultInbox
from src.execution.worker.execution_worker import ExecutionWorker, ExecutionWorkerConfig
from src.integration.normalizer import ResultNormalizer
from src.integration.registry import ExecutionAdapterRegistry


def _intent(intent_text: str = "hello", *, content_required: bool = False) -> ExecutionIntent:
    return ExecutionIntent(
        id=uuid4(),
        commitment_id=uuid4(),
        intention_id=uuid4(),
        persona_id=uuid4(),
        abstract_action="communicate",
        constraints={
            "platform": "telegram",
            "target_id": "chat-1",
            "text": intent_text,
            "content_generation_required": content_required,
        },
        created_at=datetime.now(timezone.utc),
        reversible=False,
        risk_level=0.1,
        estimated_cost=ResourceCost(1.0, 1.0, 1),
    )


class _RecordingAdapter:
    def __init__(self):
        self.received = []

    def execute(self, intent):
        self.received.append(intent)
        return ResultNormalizer.success(effects=["message_sent"], observations={"message_id": 1})


class _EnvFailAdapter:
    def __init__(self):
        self.calls = 0

    def execute(self, intent):
        self.calls += 1
        return ResultNormalizer.failure(
            reason="429 rate limit",
            failure_type=ExecutionFailureType.ENVIRONMENT,
        )


class _ContentStub:
    def apply_to_intent(self, intent, trace_id=None):
        enriched = replace(intent, constraints={**intent.constraints, "text": "generated by content service"})
        outcome = type(
            "Outcome",
            (),
            {
                "provider": "mock",
                "fallback_used": False,
                "decision": "allow",
                "error": "",
            },
        )()
        return enriched, outcome


def test_worker_applies_content_generation_before_adapter_send():
    queue = InMemoryExecutionQueue()
    inbox = InMemoryExecutionResultInbox()
    registry = ExecutionAdapterRegistry()
    adapter = _RecordingAdapter()
    registry.register("telegram", adapter)

    intent = _intent("draft", content_required=True)
    queue.enqueue(ExecutionJob.new(intent, "telegram:chat-1", {}))

    worker = ExecutionWorker(
        config=ExecutionWorkerConfig(worker_id="w1"),
        queue=queue,
        inbox=inbox,
        adapter_registry=registry,
        content_generation_service=_ContentStub(),
    )
    assert worker.run_once() == 1
    assert adapter.received[0].constraints["text"] == "generated by content service"


def test_worker_adaptive_rate_controller_delays_next_send_after_pressure_failure():
    queue = InMemoryExecutionQueue()
    inbox = InMemoryExecutionResultInbox()
    registry = ExecutionAdapterRegistry()
    adapter = _EnvFailAdapter()
    registry.register("telegram", adapter)

    job1 = queue.enqueue(ExecutionJob.new(_intent("first"), "telegram:chat-1", {}))
    job2 = queue.enqueue(ExecutionJob.new(_intent("second"), "telegram:chat-1", {}))

    controller = AdaptiveRateController(
        max_delay_seconds=5.0,
        increase_step_seconds=1.0,
        decrease_step_seconds=0.25,
        queue_lag_weight=0.0,
    )
    worker = ExecutionWorker(
        config=ExecutionWorkerConfig(worker_id="w1"),
        queue=queue,
        inbox=inbox,
        adapter_registry=registry,
        adaptive_rate_controller=controller,
    )

    assert worker.run_once() == 2

    first = queue.get(job1)
    second = queue.get(job2)
    assert first.state == ExecutionJobState.QUEUED
    assert second.state == ExecutionJobState.QUEUED
    # One of jobs should be adaptive-throttled on the hot path after pressure signal.
    assert first.last_error == "Adaptive throttling" or second.last_error == "Adaptive throttling"

